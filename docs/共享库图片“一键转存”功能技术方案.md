## 核心目标
在 Web 端实现将“作者图床（Source）”的图片资源，不经过后端服务器，直接通过浏览器前端流式传输到“用户图床（Destination）”，并替换业务数据中的图片链接。

## 技术架构
- 模式：Client-side Cross-Bucket Copy (前端跨桶复制)

- 路径： `Source OSS` -> `Browser (Memory/Blob)` -> `Destination OSS`

- 优势：不消耗应用服务器带宽，用户 AK/SK 仅在本地使用，安全性高。

## 前置条件 (已就绪)
- Source Bucket (作者端)：已配置 CORS 策略。

    - `Allowed Origins`: `*`

    - `Allowed Methods`: `GET`

    - `Exposed Headers`: `Content-Length`, `ETag`, `x-oss-request-id` (已验证，支持前端获取文件大小和进度)。

- Destination Bucket (用户端)：依赖用户填写的 OSS 配置 (Region, Bucket, AK, SK)。

## 开发实现流程 (Step-by-Step)
1. 获取源文件 (Download)

- 使用原生`fetch`请求作者图片 URL。

- 关键参数：

    - `method: 'GET'`

    - `mode: 'cors'` (必须开启，否则无法读取 Blob)。

    - Cache-Busting：URL 后必须追加时间戳 `?t=Date.now()`，防止浏览器读取旧的缓存 Header 导致 `CORS` 失败。

- 数据处理：将响应转为 `Blob` 对象。

2. 构建目标文件信息

- 文件名生成：建议使用 `前缀/日期/UUID.ext` 格式，防止重名覆盖。

- 后缀识别：优先读取 Blob 的 `type` (MIME-Type) 来确定后缀（如 `image/png`），不要完全依赖源 URL 的后缀。

3. 上传至用户图床 (Upload)

- SDK：使用 `ali-oss` (Browser version)。

- 初始化：使用用户配置的 AK/SK 初始化 Client（开启 `secure: true` 强制 HTTPS）。

- 方法：使用 `multipartUpload` 接口。

    - 理由：支持大文件分片，且提供原生 `progress` 回调，便于 UI 展示进度条。

4. 数据回填

- 上传成功后，获取新 URL。

- 强制 HTTPS：若 SDK 返回 `http://`，需替换为 `https://` 以避免 Mixed Content 警告。

- 更新当前组件/数据库中的图片 URL。

## 关键代码逻辑 (伪代码/Reference)
```
// 1. 下载：必须加时间戳绕过缓存，必须 mode: 'cors'
const response = await fetch(`${sourceUrl}?t=${Date.now()}`, { 
  mode: 'cors' 
});
const blob = await response.blob();

// 2. 上传：使用 ali-oss SDK
const client = new OSS({ ...userConfig, secure: true });
const result = await client.multipartUpload(newPath, blob, {
  progress: (p) => updateUI(p * 100) // 绑定进度条
});

// 3. 替换：处理最终链接
return result.url.replace('http://', 'https://');
```
## 常见问题排查 (Troubleshooting)
- Q: 报 CORS 错误？

    - A: 检查 `fetch` 请求是否带了时间戳参数。如果是旧的缓存请求，Header 会缺失。

- Q: 进度条不显示或 content-length 为 null？

    - A: 作者 Bucket 已配置 Expose Headers，确保 `fetch` 成功后打印 headers 确认。

- Q: 用户上传失败？

    - A: 检查用户填写的 AK/SK 权限（需具备 `PutObject` 权限），或检查目标路径是否包含非法字符。