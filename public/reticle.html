<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reticle - 瓦罗兰特瞄点编辑器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-color: #ef4444;
            --bg-dark: #0f0f11;
            --panel-bg: rgba(20, 20, 23, 0.85);
            --card-bg: rgba(255, 255, 255, 0.03);
            --card-hover: rgba(255, 255, 255, 0.06);
            --border-color: rgba(255, 255, 255, 0.08);
        }

        body {
            background-color: var(--bg-dark);
            color: #e5e5e5;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-image: radial-gradient(circle at 50% 0%, #2a1b1b 0%, #0f0f11 60%);
        }

        /* Modern Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        /* Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            transition: background 0.2s;
        }

        input[type=range]:hover::-webkit-slider-runnable-track {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--thumb-color, #ef4444);
            /* Dynamic Color */
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
            transition: transform 0.1s, box-shadow 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);
        }

        /* Color Input Reset */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            padding: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        /* Canvas Background Pattern */
        .canvas-bg {
            background-image:
                linear-gradient(45deg, #1f1f22 25%, transparent 25%),
                linear-gradient(-45deg, #1f1f22 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1f1f22 75%),
                linear-gradient(-45deg, transparent 75%, #1f1f22 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #161618;
        }

        /* Glass Panel */
        .glass-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid var(--border-color);
        }

        /* Card Style */
        .control-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.2s ease;
        }

        .control-card:hover {
            background: var(--card-hover);
            border-color: rgba(255, 255, 255, 0.15);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .loader {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 3px solid #ef4444;
            width: 32px;
            height: 32px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden text-sm selection:bg-red-500/30">

    <!-- Header -->
    <header
        class="h-14 px-6 flex justify-between items-center shrink-0 z-20 border-b border-white/5 bg-black/20 backdrop-blur-sm">
        <div class="flex items-center gap-3">
            <!-- Logo Icon -->
            <div
                class="w-8 h-8 rounded bg-gradient-to-br from-red-600 to-red-800 flex items-center justify-center text-white shadow-[0_0_15px_rgba(239,68,68,0.4)] border border-white/10">
                <i class="fas fa-crosshairs text-sm"></i>
            </div>
            <!-- Title Group -->
            <div class="flex flex-col justify-center">
                <h1 class="font-['Oswald'] font-bold tracking-wider text-lg leading-none uppercase text-white">
                    Reticle <span class="text-red-500 text-[10px] align-top ml-0.5">BETA</span>
                </h1>
                <p class="text-[10px] text-gray-500 font-medium tracking-widest uppercase scale-90 origin-left">
                    瓦罗兰特点位编辑器</p>
            </div>
        </div>

        <!-- Right Action Buttons -->
        <div class="flex items-center gap-3">
            <button id="upload-btn-header"
                class="bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg border border-white/10 transition-all flex items-center justify-center gap-2 px-3 py-1.5 text-xs font-medium h-8 hover:border-white/20">
                <i class="fas fa-sync-alt"></i> <span class="hidden sm:inline">换图</span>
            </button>
            <button id="copy-btn-header"
                class="bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg border border-white/10 transition-all flex items-center justify-center gap-2 px-3 py-1.5 text-xs font-medium h-8 hover:border-white/20 disabled:opacity-50 disabled:cursor-not-allowed">
                <i class="fas fa-copy"></i> <span class="hidden sm:inline">复制</span>
            </button>
            <button id="download-btn-header"
                class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-500 hover:to-red-600 text-white rounded-lg shadow-[0_4px_12px_rgba(220,38,38,0.3)] border border-white/10 transition-all transform active:scale-95 flex items-center justify-center gap-2 px-4 py-1.5 text-xs font-bold tracking-wide disabled:opacity-50 disabled:cursor-not-allowed h-8">
                <i class="fas fa-download"></i> <span class="hidden sm:inline">保存</span>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden relative">

        <!-- Canvas Area -->
        <div class="flex-1 relative flex items-center justify-center p-6 overflow-hidden group" id="canvas-wrapper">

            <!-- Empty State -->
            <div id="empty-state"
                class="text-center p-12 border border-dashed border-white/10 rounded-2xl bg-white/5 hover:bg-white/10 hover:border-red-500/50 transition-all cursor-pointer group-hover:shadow-2xl shadow-black/50 backdrop-blur-sm">
                <div
                    class="w-16 h-16 bg-white/5 rounded-full flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform duration-300 ring-1 ring-white/10">
                    <i class="fas fa-image text-2xl text-gray-400 group-hover:text-red-500 transition-colors"></i>
                </div>
                <h3 class="text-lg font-semibold text-gray-200">点击上传图片</h3>
                <p class="text-gray-500 text-xs mt-1">支持 JPG, PNG, WEBP (Max 20MB)</p>
                <input type="file" id="file-upload" class="hidden" accept="image/*">
            </div>

            <!-- Canvas Wrapper -->
            <div id="canvas-box"
                class="hidden shadow-[0_20px_50px_-12px_rgba(0,0,0,0.5)] rounded-sm overflow-hidden border border-white/5 canvas-bg relative">
                <canvas id="editor-canvas" class="block"></canvas>
                <div id="loading-overlay"
                    class="absolute inset-0 bg-black/60 hidden items-center justify-center z-50 backdrop-blur-sm">
                    <div class="loader"></div>
                </div>
            </div>

        </div>

        <!-- Controls Panel (Glassmorphism) -->
        <section class="glass-panel shrink-0 z-30 h-auto overflow-y-auto custom-scroll">
            <div class="max-w-[1600px] mx-auto p-4 md:p-6">
                <!-- 4 Column Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">

                    <!-- Col 1: Lens Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-crosshairs text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">镜头参数</span>
                            </div>
                            <!-- Updated: Capsule Style Lock Button -->
                            <button id="btn-lock"
                                class="group flex items-center gap-1.5 px-3 py-1 rounded-full bg-red-500/20 border border-red-500/30 text-red-400 hover:bg-red-500 hover:text-white transition-all text-[10px] font-medium shadow-[0_0_10px_rgba(239,68,68,0.1)] hover:shadow-[0_0_15px_rgba(239,68,68,0.3)]">
                                <i class="fas fa-lock text-[10px]"></i>
                                <span>位置锁定</span>
                            </button>
                        </div>

                        <div class="space-y-4">
                            <!-- Zoom -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">倍率</span>
                                <input type="range" id="param-zoom" min="1.1" max="5.0" step="0.1" value="3.0">
                                <span id="val-zoom" class="text-xs font-mono text-gray-300 text-right">3.0x</span>
                            </div>
                            <!-- Size -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">尺寸</span>
                                <input type="range" id="param-size" min="100" max="400" step="10" value="280">
                                <span id="val-size" class="text-xs font-mono text-gray-300 text-right">280</span>
                            </div>
                            <!-- Aim Radius -->
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">准心</span>
                                <input type="range" id="param-aim" min="5" max="100" step="1" value="16">
                                <span id="val-aim" class="text-xs font-mono text-gray-300 text-right">16</span>
                            </div>
                        </div>
                    </div>

                    <!-- Col 2: Style Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-paint-brush text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">样式设置</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-[10px] text-gray-500">颜色</span>
                                <input type="color" id="param-color" value="#ef4444" title="主题颜色">
                            </div>
                        </div>

                        <div class="space-y-4">
                            <!-- Border Width -->
                            <div class="grid grid-cols-[48px_1fr_30px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">框粗细</span>
                                <input type="range" id="param-border-w" min="1" max="20" step="1" value="6">
                                <span id="val-border-w" class="text-xs font-mono text-gray-300 text-right">6</span>
                            </div>
                            <!-- Aim Width -->
                            <div class="grid grid-cols-[48px_1fr_30px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">准粗细</span>
                                <input type="range" id="param-aim-w" min="1" max="10" step="1" value="4">
                                <span id="val-aim-w" class="text-xs font-mono text-gray-300 text-right">4</span>
                            </div>
                            <!-- Text Stroke Width (New) -->
                            <div class="grid grid-cols-[48px_1fr_30px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">字描边</span>
                                <input type="range" id="param-text-stroke" min="0" max="20" step="1" value="8">
                                <span id="val-text-stroke" class="text-xs font-mono text-gray-300 text-right">8</span>
                            </div>
                        </div>
                    </div>

                    <!-- Col 3: Text Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center justify-between border-b border-white/5 pb-2">
                            <div class="flex items-center gap-2 text-gray-400">
                                <i class="fas fa-font text-xs"></i>
                                <span class="text-xs font-bold uppercase tracking-wider">文字标注</span>
                            </div>
                            <!-- Removed Toggle Switch -->
                            <span class="text-[10px] text-gray-600 italic">输入即显示</span>
                        </div>

                        <div class="flex flex-col gap-3">
                            <!-- Line 1 -->
                            <div class="flex items-center gap-2">
                                <div class="w-1 h-8 rounded-full bg-red-500 shrink-0"></div>
                                <div class="flex-1 relative">
                                    <input type="text" id="text-line1" placeholder="第一行文字 (红)"
                                        class="w-full bg-white/5 border border-white/5 rounded-lg px-2 py-1.5 text-xs text-gray-200 focus:border-red-500/50 focus:bg-white/10 focus:outline-none transition-all placeholder-gray-600">
                                </div>
                                <div class="shrink-0 pt-1">
                                    <input type="color" id="color-line1" value="#FF0000" title="选择颜色">
                                </div>
                            </div>
                            <!-- Line 2 -->
                            <div class="flex items-center gap-2">
                                <div class="w-1 h-8 rounded-full bg-purple-500 shrink-0"></div>
                                <div class="flex-1 relative">
                                    <input type="text" id="text-line2" placeholder="第二行文字 (紫)"
                                        class="w-full bg-white/5 border border-white/5 rounded-lg px-2 py-1.5 text-xs text-gray-200 focus:border-purple-500/50 focus:bg-white/10 focus:outline-none transition-all placeholder-gray-600">
                                </div>
                                <div class="shrink-0 pt-1">
                                    <input type="color" id="color-line2" value="#a600ff" title="选择颜色">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Col 4: Export Settings -->
                    <div class="control-card p-4 flex flex-col gap-4 h-full">
                        <div class="flex items-center gap-2 text-gray-400 border-b border-white/5 pb-2">
                            <i class="fas fa-sliders-h text-xs"></i>
                            <span class="text-xs font-bold uppercase tracking-wider">输出设置</span>
                        </div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">画质</span>
                                <input type="range" id="param-quality" min="10" max="100" step="5" value="80">
                                <span id="val-quality" class="text-xs font-mono text-gray-300 text-right">80%</span>
                            </div>
                            <div class="grid grid-cols-[32px_1fr_40px] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">缩放</span>
                                <input type="range" id="param-scale" min="0.1" max="1.0" step="0.1" value="1.0">
                                <span id="val-scale" class="text-xs font-mono text-gray-300 text-right">100%</span>
                            </div>
                            <!-- Format Selector -->
                            <div class="grid grid-cols-[32px_1fr] gap-3 items-center">
                                <span class="text-xs text-gray-500 font-medium">格式</span>
                                <div class="flex items-center gap-2" id="format-btns">
                                    <button type="button" data-format="png"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-red-500/20 border border-red-500/30 text-red-400 shadow-[0_0_10px_rgba(239,68,68,0.1)]">PNG</button>
                                    <button type="button" data-format="jpg"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">JPG</button>
                                    <button type="button" data-format="webp"
                                        class="format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200">WebP</button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </section>
    </main>

    <script>
        // --- State Management ---
        const state = {
            image: null,
            canvasScale: 1,
            fileName: null,
            fileType: null,

            lens: {
                x: 8,
                y: 8,
                radius: 140, // 280 / 2
                zoom: 3.0,
                aimRadius: 16,
                // New Style Params
                borderWidth: 6,
                aimWidth: 4,
                borderColor: '#ef4444'
            },

            watermark: {
                // show: false, // Removed explicit show flag
                line1: "",
                line2: "",
                color1: '#FF0000',
                color2: '#a600ff',
                strokeWidth: 8
            },

            target: { x: 0, y: 0 },

            isLensLocked: true,
            isDraggingLens: false,
            isDraggingContent: false,
            lastMouse: { x: 0, y: 0 },
            exportFormat: 'png'  // Default export format
        };

        // --- DOM Elements ---
        const els = {
            fileInput: document.getElementById('file-upload'),
            emptyState: document.getElementById('empty-state'),
            uploadBtn: document.getElementById('upload-btn-header'),
            downloadBtn: document.getElementById('download-btn-header'),
            copyBtn: document.getElementById('copy-btn-header'),

            canvasBox: document.getElementById('canvas-box'),
            canvas: document.getElementById('editor-canvas'),
            canvasWrapper: document.getElementById('canvas-wrapper'),

            btnLock: document.getElementById('btn-lock'),

            // Params
            zoom: document.getElementById('param-zoom'),
            size: document.getElementById('param-size'),
            aim: document.getElementById('param-aim'),
            quality: document.getElementById('param-quality'),
            scale: document.getElementById('param-scale'),

            // New Style Inputs
            borderW: document.getElementById('param-border-w'),
            aimW: document.getElementById('param-aim-w'),
            textStroke: document.getElementById('param-text-stroke'),
            color: document.getElementById('param-color'),

            // Watermark
            // toggleWatermark: document.getElementById('toggle-watermark'), // Removed
            textLine1: document.getElementById('text-line1'),
            textLine2: document.getElementById('text-line2'),
            colorLine1: document.getElementById('color-line1'),
            colorLine2: document.getElementById('color-line2'),

            // Labels
            valZoom: document.getElementById('val-zoom'),
            valSize: document.getElementById('val-size'),
            valAim: document.getElementById('val-aim'),
            valQuality: document.getElementById('val-quality'),
            valScale: document.getElementById('val-scale'),
            valBorderW: document.getElementById('val-border-w'),
            valAimW: document.getElementById('val-aim-w'),
            valTextStroke: document.getElementById('val-text-stroke'), // New
        };

        const ctx = els.canvas.getContext('2d');

        // --- Initialization ---
        function init() {
            els.emptyState.addEventListener('click', () => els.fileInput.click());
            els.uploadBtn.addEventListener('click', () => els.fileInput.click());
            els.fileInput.addEventListener('change', handleFileSelect);

            els.canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);

            els.canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleMouseUp);

            els.btnLock.addEventListener('click', toggleLock);

            // Event Listeners for all inputs
            const inputs = [
                els.zoom, els.size, els.aim, els.quality, els.scale,
                els.borderW, els.aimW, els.textStroke, els.color,
                els.textLine1, els.textLine2, els.colorLine1, els.colorLine2 // Removed toggle
            ];

            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    updateParams();
                });
            });

            els.downloadBtn.addEventListener('click', downloadImage);
            els.downloadBtn.disabled = true;
            els.copyBtn.addEventListener('click', copyImage);
            els.copyBtn.disabled = true;

            // Format toggle buttons
            document.querySelectorAll('.format-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.exportFormat = btn.dataset.format;
                    // Update button styles
                    document.querySelectorAll('.format-btn').forEach(b => {
                        if (b === btn) {
                            b.className = 'format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-red-500/20 border border-red-500/30 text-red-400 shadow-[0_0_10px_rgba(239,68,68,0.1)]';
                        } else {
                            b.className = 'format-btn px-3 py-1 rounded-lg text-[10px] font-medium transition-all bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200';
                        }
                    });
                });
            });

            window.addEventListener('resize', () => {
                if (state.image) {
                    setupCanvas();
                    render();
                }
            });
        }

        // --- Logic ---
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.image = img;
                    setupCanvas();

                    state.lens.x = 8;
                    state.lens.y = 8;
                    state.target.x = img.width / 2;
                    state.target.y = img.height / 2;
                    state.fileName = file.name || null;
                    state.fileType = file.type || null;

                    render();
                    els.emptyState.classList.add('hidden');
                    els.canvasBox.classList.remove('hidden');
                    els.downloadBtn.disabled = false;
                    els.copyBtn.disabled = false;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas() {
            if (!state.image) return;
            const wrapper = els.canvasWrapper;
            const maxWidth = wrapper.clientWidth - 48; // p-6 * 2
            const maxHeight = wrapper.clientHeight - 48;

            const imgRatio = state.image.width / state.image.height;
            const containerRatio = maxWidth / maxHeight;

            let finalWidth, finalHeight;

            if (imgRatio > containerRatio) {
                finalWidth = maxWidth;
                finalHeight = maxWidth / imgRatio;
            } else {
                finalHeight = maxHeight;
                finalWidth = maxHeight * imgRatio;
            }

            els.canvas.width = finalWidth;
            els.canvas.height = finalHeight;
            els.canvas.style.width = finalWidth + 'px';
            els.canvas.style.height = finalHeight + 'px';

            state.canvasScale = state.image.width / finalWidth;
        }

        function getExportType() {
            const mimeMap = { 'png': 'image/png', 'jpg': 'image/jpeg', 'webp': 'image/webp' };
            return mimeMap[state.exportFormat] || 'image/png';
        }

        function getExportName(exportType) {
            const extMap = { 'image/webp': 'webp', 'image/png': 'png', 'image/jpeg': 'jpg' };
            const ext = extMap[exportType] || 'png';
            if (state.fileName) {
                const base = state.fileName.replace(/\.[^.]+$/, '');
                return `${base}.${ext}`;
            }
            return `magnifier_edit_${Date.now()}.${ext}`;
        }

        function toggleLock() {
            state.isLensLocked = !state.isLensLocked;
            const icon = els.btnLock.querySelector('i');
            const span = els.btnLock.querySelector('span');

            if (state.isLensLocked) {
                icon.className = 'fas fa-lock text-[10px]';
                span.textContent = '位置锁定';
                // Active Capsule Style
                els.btnLock.className = 'group flex items-center gap-1.5 px-3 py-1 rounded-full bg-red-500/20 border border-red-500/30 text-red-400 hover:bg-red-500 hover:text-white transition-all text-[10px] font-medium shadow-[0_0_10px_rgba(239,68,68,0.1)] hover:shadow-[0_0_15px_rgba(239,68,68,0.3)]';
            } else {
                icon.className = 'fas fa-unlock text-[10px]';
                span.textContent = '拖动调整';
                // Inactive Capsule Style
                els.btnLock.className = 'group flex items-center gap-1.5 px-3 py-1 rounded-full bg-white/5 border border-white/10 text-gray-400 hover:bg-white/10 hover:text-gray-200 transition-all text-[10px] font-medium';
            }
            render();
        }

        function updateParams() {
            // Lens Basic
            state.lens.zoom = parseFloat(els.zoom.value);
            state.lens.radius = parseInt(els.size.value) / 2;
            state.lens.aimRadius = parseInt(els.aim.value);

            // Lens Style
            state.lens.borderWidth = parseInt(els.borderW.value);
            state.lens.aimWidth = parseInt(els.aimW.value);
            state.lens.borderColor = els.color.value;

            // Watermark
            // state.watermark.show = els.toggleWatermark.checked; // Removed
            state.watermark.line1 = els.textLine1.value;
            state.watermark.line2 = els.textLine2.value;
            state.watermark.color1 = els.colorLine1.value;
            state.watermark.color2 = els.colorLine2.value;
            state.watermark.strokeWidth = parseInt(els.textStroke.value);

            // Update thumb color CSS var for feedback
            document.documentElement.style.setProperty('--thumb-color', state.lens.borderColor);

            // Labels
            els.valZoom.textContent = state.lens.zoom.toFixed(1) + 'x';
            els.valSize.textContent = (state.lens.radius * 2);
            els.valAim.textContent = state.lens.aimRadius;
            els.valQuality.textContent = els.quality.value + '%';
            els.valScale.textContent = Math.round(els.scale.value * 100) + '%';
            els.valBorderW.textContent = state.lens.borderWidth;
            els.valAimW.textContent = state.lens.aimWidth;
            els.valTextStroke.textContent = state.watermark.strokeWidth;

            render();
        }

        function render() {
            if (!state.image) return;

            const w = els.canvas.width;
            const h = els.canvas.height;

            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(state.image, 0, 0, w, h);

            // Watermark (Logic Change: Check strings directly)
            const hasWatermark = state.watermark.line1 || state.watermark.line2;

            if (hasWatermark) {
                ctx.save();

                const fontSize = 32;
                const lineHeight = fontSize * 1.4;
                ctx.font = `900 ${fontSize}px "Segoe UI", Roboto, sans-serif`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';

                const padding = 20;
                const x = w - padding;
                let y = padding;

                // Use dynamic stroke width
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = state.watermark.strokeWidth;
                ctx.lineJoin = 'round';
                ctx.miterLimit = 2;
                ctx.shadowColor = 'transparent';

                if (state.watermark.line1) {
                    if (state.watermark.strokeWidth > 0) ctx.strokeText(state.watermark.line1, x, y);
                    ctx.fillStyle = state.watermark.color1;
                    ctx.fillText(state.watermark.line1, x, y);
                }

                if (state.watermark.line2) {
                    if (state.watermark.line1) y += lineHeight;
                    if (state.watermark.strokeWidth > 0) ctx.strokeText(state.watermark.line2, x, y);
                    ctx.fillStyle = state.watermark.color2;
                    ctx.fillText(state.watermark.line2, x, y);
                }
                ctx.restore();
            }

            // Lens Content
            const lensX = state.lens.x + state.lens.radius;
            const lensY = state.lens.y + state.lens.radius;
            const lensR = state.lens.radius;

            ctx.save();
            ctx.beginPath();
            ctx.arc(lensX, lensY, lensR, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = '#fff';
            ctx.fill();

            const viewW = (lensR * 2 * state.canvasScale) / state.lens.zoom;
            const viewH = viewW;
            const sx = state.target.x - (viewW / 2);
            const sy = state.target.y - (viewH / 2);

            ctx.drawImage(
                state.image,
                sx, sy, viewW, viewH,
                lensX - lensR, lensY - lensR, lensR * 2, lensR * 2
            );
            ctx.restore();

            // Lens UI
            ctx.save();
            // Border
            ctx.beginPath();
            ctx.arc(lensX, lensY, lensR, 0, Math.PI * 2);
            ctx.lineWidth = state.lens.borderWidth;
            ctx.strokeStyle = state.lens.borderColor;
            ctx.stroke();

            // Aim
            ctx.beginPath();
            ctx.arc(lensX, lensY, state.lens.aimRadius, 0, Math.PI * 2);
            ctx.lineWidth = state.lens.aimWidth;
            ctx.strokeStyle = state.lens.borderColor;
            ctx.stroke();

            // Handle
            if (!state.isLensLocked) {
                const handleAngle = Math.PI * 1.25;
                const handleDist = lensR;
                const handleX = lensX + Math.cos(handleAngle) * handleDist;
                const handleY = lensY + Math.sin(handleAngle) * handleDist;

                ctx.beginPath();
                ctx.arc(handleX, handleY, 14, 0, Math.PI * 2);
                ctx.fillStyle = state.lens.borderColor;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(handleX - 4, handleY);
                ctx.lineTo(handleX + 4, handleY);
                ctx.moveTo(handleX, handleY - 4);
                ctx.lineTo(handleX, handleY + 4);
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();

            if (state.isDraggingLens) {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(lensX - 40, lensY - lensR - 30, 80, 24, 4);
                ctx.fill();
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText("移动镜框", lensX, lensY - lensR - 14);
                ctx.restore();
            }
        }

        // --- Interaction ---
        function getMousePos(evt) {
            const rect = els.canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleMouseDown(e) {
            if (!state.image) return;
            const pos = getMousePos(e);

            const lensCenterX = state.lens.x + state.lens.radius;
            const lensCenterY = state.lens.y + state.lens.radius;

            const handleAngle = Math.PI * 1.25;
            const handleX = lensCenterX + Math.cos(handleAngle) * state.lens.radius;
            const handleY = lensCenterY + Math.sin(handleAngle) * state.lens.radius;
            const distToHandle = Math.hypot(pos.x - handleX, pos.y - handleY);
            const distToCenter = Math.hypot(pos.x - lensCenterX, pos.y - lensCenterY);

            if (!state.isLensLocked && distToHandle < 20) {
                state.isDraggingLens = true;
                els.canvas.style.cursor = 'move';
            } else if (distToCenter < state.lens.radius) {
                state.isDraggingContent = true;
                els.canvas.style.cursor = 'grab';
            } else if (!state.isLensLocked) {
                state.lens.x = pos.x - state.lens.radius;
                state.lens.y = pos.y - state.lens.radius;
                render();
            }
            state.lastMouse = pos;
        }

        function handleTouchStart(e) { e.preventDefault(); handleMouseDown(e); }

        function handleMouseMove(e) {
            if (!state.isDraggingLens && !state.isDraggingContent) return;
            if (!state.image) return;

            const pos = getMousePos(e);
            const dx = pos.x - state.lastMouse.x;
            const dy = pos.y - state.lastMouse.y;

            if (state.isDraggingLens && !state.isLensLocked) {
                state.lens.x += dx;
                state.lens.y += dy;
            } else if (state.isDraggingContent) {
                state.target.x -= dx * state.canvasScale / state.lens.zoom;
                state.target.y -= dy * state.canvasScale / state.lens.zoom;
            }

            state.lastMouse = pos;
            render();
        }

        function handleTouchMove(e) { e.preventDefault(); handleMouseMove(e); }

        function handleMouseUp() {
            state.isDraggingLens = false;
            state.isDraggingContent = false;
            els.canvas.style.cursor = 'default';
        }

        // 生成导出画布，复用给下载与复制
        function buildExportCanvas() {
            if (!state.image) return null;

            const scale = parseFloat(els.scale.value);
            const quality = parseInt(els.quality.value) / 100;

            const exportCanvas = document.createElement('canvas');
            const eCtx = exportCanvas.getContext('2d');

            const finalW = state.image.width * scale;
            const finalH = state.image.height * scale;

            exportCanvas.width = finalW;
            exportCanvas.height = finalH;

            const previewW = els.canvas.width;
            const ratio = finalW / previewW;

            const exportLensR = state.lens.radius * ratio;
            const exportLensX = state.lens.x * ratio;
            const exportLensY = state.lens.y * ratio;
            const exportAimR = state.lens.aimRadius * ratio;

            eCtx.drawImage(state.image, 0, 0, finalW, finalH);

            const hasWatermark = state.watermark.line1 || state.watermark.line2;

            if (hasWatermark) {
                eCtx.save();
                const fontSize = 32 * ratio;
                const lineHeight = fontSize * 1.4;
                eCtx.font = `900 ${fontSize}px "Segoe UI", Roboto, sans-serif`;
                eCtx.textAlign = 'right';
                eCtx.textBaseline = 'top';

                const padding = 20 * ratio;
                const x = finalW - padding;
                let y = padding;

                eCtx.strokeStyle = '#FFFFFF';
                eCtx.lineWidth = state.watermark.strokeWidth * ratio;
                eCtx.lineJoin = 'round';
                eCtx.miterLimit = 2;
                eCtx.shadowColor = 'transparent';

                if (state.watermark.line1) {
                    if (state.watermark.strokeWidth > 0) eCtx.strokeText(state.watermark.line1, x, y);
                    eCtx.fillStyle = state.watermark.color1;
                    eCtx.fillText(state.watermark.line1, x, y);
                }

                if (state.watermark.line2) {
                    if (state.watermark.line1) y += lineHeight;
                    if (state.watermark.strokeWidth > 0) eCtx.strokeText(state.watermark.line2, x, y);
                    eCtx.fillStyle = state.watermark.color2;
                    eCtx.fillText(state.watermark.line2, x, y);
                }
                eCtx.restore();
            }

            const lensCenterX = exportLensX + exportLensR;
            const lensCenterY = exportLensY + exportLensR;

            eCtx.save();
            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportLensR, 0, Math.PI * 2);
            eCtx.clip();
            eCtx.fillStyle = '#fff';
            eCtx.fill();

            const viewW = (state.lens.radius * 2 * state.canvasScale) / state.lens.zoom;
            const viewH = viewW;
            const sx = state.target.x - (viewW / 2);
            const sy = state.target.y - (viewH / 2);

            eCtx.drawImage(
                state.image,
                sx, sy, viewW, viewH,
                exportLensX, exportLensY, exportLensR * 2, exportLensR * 2
            );
            eCtx.restore();

            eCtx.save();
            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportLensR, 0, Math.PI * 2);
            eCtx.lineWidth = state.lens.borderWidth * ratio;
            eCtx.strokeStyle = state.lens.borderColor;
            eCtx.stroke();

            eCtx.beginPath();
            eCtx.arc(lensCenterX, lensCenterY, exportAimR, 0, Math.PI * 2);
            eCtx.lineWidth = state.lens.aimWidth * ratio;
            eCtx.strokeStyle = state.lens.borderColor;
            eCtx.stroke();
            eCtx.restore();

            return { exportCanvas, quality };
        }

        function downloadImage() {
            const result = buildExportCanvas();
            if (!result) return;
            const { exportCanvas, quality } = result;
            const exportType = getExportType();

            const dataURL = exportCanvas.toDataURL(exportType, quality);
            const downloadName = getExportName(exportType);
            const link = document.createElement('a');
            link.download = downloadName;
            link.href = dataURL;
            link.click();
        }

        async function copyImage() {
            const result = buildExportCanvas();
            if (!result) return;
            const { exportCanvas, quality } = result;

            if (!navigator.clipboard || !navigator.clipboard.write || typeof ClipboardItem === 'undefined') {
                alert('当前环境不支持剪贴板复制。');
                return;
            }

            try {
                let mimeCandidates = [
                    { type: 'image/png', quality: 1 },
                    { type: 'image/jpeg', quality }
                ];

                if (typeof ClipboardItem?.supports === 'function') {
                    mimeCandidates = mimeCandidates.filter(c => ClipboardItem.supports(c.type));
                }

                const blobEntries = [];
                for (const candidate of mimeCandidates) {
                    const blob = await new Promise(resolve => exportCanvas.toBlob(resolve, candidate.type, candidate.quality));
                    if (blob) {
                        blobEntries.push([candidate.type, blob]);
                    }
                }

                if (blobEntries.length === 0) {
                    alert('导出图片失败，当前环境不支持 JPG/PNG 剪贴板写入。');
                    return;
                }

                await navigator.clipboard.write([
                    new ClipboardItem(Object.fromEntries(blobEntries))
                ]);

                els.copyBtn.textContent = '已复制';
                setTimeout(() => { els.copyBtn.innerHTML = '<i class="fas fa-copy"></i> <span class="hidden sm:inline">复制</span>'; }, 1200);
            } catch (err) {
                alert('复制到剪贴板失败：' + err.message);
            }
        }

        init();
    </script>
</body>

</html>